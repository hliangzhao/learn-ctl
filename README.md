## 类Unix系统命令行速查清单
（本文档所述内容的测试环境为macOS 10.14 & zsh 5.7）
### 一、学习shell
1、一个类Unix的操作系统以**分层目录结构**来组织所有文件，组成了一棵树形目录。
类Unix的操作系统只有一个单一的文件系统树，不管有多少个磁盘或者存储设备连接到计算机上。
根据负责维护系统安全的系统管理员的兴致，存储设备**挂载**到（mount）目录树的各个节点上。

2、Linux没有“文件扩展名”的概念，可以用任何名字来给文件起名。文件内容或用途由其它方法来决定。

3、相关命令：``pwd``，``cd``，``ls``，``file``（确定文件类型），``less``（浏览文件内容）、`rm`、`cp`、`mv`、`mkdir`、`ln`（创建硬链接和符号链接）。

4、``ls``命令记不住的选项：
|  选项  | 描述
|  ---- | ----
| `-d, --directory` | 通常，如果指定了目录名，`ls`命令会列出这个目录中的内容，而不是目录本身。 把这个选项与`-l`选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。
| ``-h, --human-readable`` | 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。
| ``-S``  | 命令输出结果按照文件大小来排序。
| ``-t``  | 按照修改时间来排序。
<br>

5、``ls -a``的输出格式中，第二个表示文件硬链接的个数。
```
-rw-r--r--@  1 hliangzhao  staff   1.6K Jan 17 10:20 .bash_profile
```

6、什么是**文本**（text）？
在计算机中，信息的表达与记录是通过映射到数字来实现的。**文本**是简单的字符与数字之间的一对一映射。五十个字符的文本翻译成五十个字节的数据。纯ASCII文件只包含字符本身和一些基本的控制符（如制表符、回车符及换行符等）。相反，如``.docx``这样的文字处理器文档包含许多非文本元素，来描述它的结构和格式。

在Linux系统中，大多数系统配置文件和脚本文件都是文本文件。

7、Linux系统目录

| 目录 | 描述
| --- | ---
| ``/bin`` | 包含系统启动和运行所必须的二进制程序。
| ``/boot`` | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。
|  ``/dev`` | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。
| ``/etc`` | 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。<br> <ui><li>``/etc/crontab``：定义自动运行的任务。</li><li>`/etc/fstab`：包含存储设备的列表，以及与他们相关的挂载点。</li><li>`/etc/passwd`：包含用户帐号列表。</li></ui>
| ``/home``| 在通常的配置环境下，系统会在\/home`下，给每个用户分配一个目录。普通用户只能在自己的目录下**写**文件。这个限制保护系统免受错误的用户活动破坏。 | 
| ``/lib`` | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。
| ``/media`` | （现代Linux）包含**可移动介质**的挂载点， 例如USB驱动器，CD-ROMs等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。
| ``/mnt`` | （早期Linux）包含可移动介质的挂载点。
| ``/opt`` | 被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。
| ``/proc`` | 从存储在硬盘上的文件的意义上说，它不是真正的文件系统。相反，它是一个由Linux内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的，它们会告诉你内核是怎样监管计算机的。
| ``/root`` | root账户的home directory。
| ``/tmp`` | 用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次重新启动时，都会清空这个目录。
| ``/usr`` | 包含普通用户所需要的所有程序和文件（User System Resource）。
| ``/usr/bin`` | 包含系统安装的可执行程序。通常，这个目录会包含许多程序。
| ``/usr/lib`` | 包含由/usr/bin 目录中的程序所用的共享库。
| ``/usr/local`` | 这是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在``/usr/local/bin``目录下。新安装的Linux系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。
| ``/usr/sbin`` | 包含许多系统管理程序（system binary）。
| ``/usr/share`` | 包含许多由``/usr/bin``目录中的程序使用的共享数据。其中包括像默认的配置文件、图标、桌面背景、音频文件等等。
| ``/usr/share/doc`` | 大多数安装在系统中的软件包会包含一些文档。在该目录我们可以找到按照软件包分类的文档。
| ``/var`` | 除了``/tmp``和``/home``目录之外，相对来说，目前我们看到的目录是静态的，这是说，它们的内容不会改变。``/var``目录存放的是动态文件。各种数据库、假脱机文件、用户邮件等等，都位于在这里。
| ``/var/log`` | 包含日志文件、各种系统活动的记录。这些文件非常重要，并且应该时时监测它们。其中最重要的一个文件是``/var/log/messages``。注意，为了系统安全，在一些系统中，你必须是超级用户才能查看这些日志文件。
<br>

8、通配符：这是shell提供的特殊字符，用来帮助我们快速指定一组文件名。**接受文件名作为参数的任何命令，都可以使用通配符。**

| 通配符 | 意义
| --- | --- 
| `*` | 匹配任意多个字符（包括零个或一个）
| `?` | 匹配任意一个字符（不包括零个）
| `[characters]` | 匹配任意一个属于**字符集**中的字符
| `[!characters]` | 匹配任意一个不是字符集中的字符
| `[[:class:]]` | 匹配任意一个属于**指定字符类**中的字符

常用的字符类有：
| 字符类 | 意义
| --- | ---
| `[:alnum:]` | 匹配任意一个字母或数字
| `[:alpha:]` | 匹配任意一个字母
| `[:digit:]` | 匹配任意一个数字
| `[:lower:]` | 匹配任意一个小写字母
| `[:upper:]` | 匹配任意一个大写字母

通配符的案例：
| 模式 | 匹配对象
| --- | ---
| `*` | 所有文件
| `g*` | 文件名以“g”开头的文件
| `b*.txt` | 以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件
| `Data???` | 以“Data”开头，其后紧接着3个字符的文件
| `[abc]*` | 文件名以"a","b",或"c"开头的文件
| `BACKUP.[0-9][0-9][0-9]` | 以"BACKUP."开头，并紧接着3个数字的文件
| `[[:upper:]]*` | 以大写字母开头的文件
| `[![:digit:]]*` | 不以数字开头的文件
| `*[[:lower:]123]` | 文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件
<br>

9、`cp`的参数：
选项 | 意义
--- | ---
`-a, --archive` | 复制文件和目录，**以及它们的属性**，包括拥有者和所有权。 通常，副本具有用户所操作文件的默认属性。
`-i, --interactive` | 在重写已存在文件之前，提示用户确认。如果这个选项不指定， `cp`命令会默认重写文件。
`-r, --recursive` | 递归地复制目录及目录中的内容。当复制目录时，需要这个选项（或者`-a`选项）。
`-u, --update` | 当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。
`-v, --verbose` | 显示翔实的命令操作信息

`cp`、`mv`、`rm`、`mkdir`等均可用`-v`参数来输出帮助命令。用`man（或者info） command`来查阅更为全面详细的命令参数信息。
<br>

10、硬链接与符号链接：

**硬链接**是最初Unix创建链接的方式。每个文件默认会有一个硬链接，这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目录项。硬链接有两个重要局限性：
- 一个硬链接不能关联它所在文件系统之外的文件（不能关联与链接本身不在同一个磁盘分区上的文件）。
- 一个硬链接不能关联一个目录。

**符号链接**生效，是通过创建一个 特殊类型的文件，这个文件包含一个关联文件或目录的文本指针（类似“快捷方式”）。对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。 而`rm`命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。

``ls -i``可显示文件索引节点号（index），索引节点相同则表示是同一个文件。

11、什么是命令？

- 是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 这一类程序可以是用诸如 C 和 C++语言写成的程序编译的二进制文件, 也可以是由诸如shell，perl，python，ruby等等脚本语言写成的程序 。
- 是一个内建于shell自身的命令。bash支持若干命令，内部叫做shell内部命令 (builtins)。例如，`cd`、`mv`等。
- 是一个 shell 函数。
- 是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。

用以下命令查阅和理解命令：
* `type` – 说明怎样解释一个命令名
* `which` – 显示会执行哪个可执行程序（只对可执行程序有效，不包括内建命令和命令别名）
* `man` – 显示命令手册页（养成使用`man`的习惯！）
* `apropos` – 显示一系列适合的命令
* `info` – 显示命令
* `whatis` – 显示一个命令的简洁描述
* `alias` – 创建命令别名（e.g.，`alias foo='cd /usr; ls; cd -'，unalias foo`），仅在shell会话内有效。

12、**重定向**

（1）**常用命令**
- `cat` － 连接/显示文件
- `sort` － 排序文本行
- `uniq` － 报道或省略重复行
- `grep` － 打印匹配行
- `wc` － 打印文件中换行符，字，和字节个数
- `head` － 输出文件第一部分（`-n num`将将默认输出的行数设置为num）
- `tail` - 输出文件最后一部分（同上）
- `tee` - 从标准输入读取数据，并同时写到标准输出和文件

（2）与Unix主题“任何东西都是一个文件”保持一致，像`ls`这样的程序实际上把他们的运行结果输送到一个叫做**标准输出**的特殊文件（`stdout`），而它们的状态信息则送到另一个叫做**标准错误**的文件（`stderr`）。默认情况下，标准输出和标准错误都连接到屏幕。除此之外，许多程序从一个叫做标准输入（`stdin`）的设备得到输入，默认情况下，标准输入连接到键盘。I/O 重定向允许我们更改输出地点和输入来源。一般来说，输入来自键盘，输出送到屏幕，但是通过I/O重定向，我们可以做出改变。

（3）**标准输出重定向：**
使用“>”*重定向符后接文件名*将标准输出重定向到屏幕以外的一个文件（没错！屏幕也可以视为一个文件）。当我们使用“>”重定向符来重定向输出结果时，目标文件总是从开头被重写。如果命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后由于错误而停止，导致文件内容清空。使用”>>“重定向符将命令的输出追加到重定向文件。
- `ls -l /usr/bin > ls-output.txt`（重写）
- `ls -l /usr/bin >> ls-output.txt`（追加）

（4）**标准错误重定向：**
文件流的前三个称作标准输入、输出和错误，shell内部分别将其称为文件描述符0、1和2。
- `ls -l /bin/usr 2> ls-error.txt`（如果命令有错误，则写入文件，否则文件为空）

（5）**重定向标准输出和错误到同一个文件：**
- `ls -l /bin/usr > ls-output.txt 2>&1`（首先重定向标准输出到文件ls-output.txt，然后重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法`2>&1`。如果没出错，则标准错误为空，因此`ls-output.txt`不会被追加任何信息；如果出错了，则一开始`ls-output.txt`为空，但是标准错误不为空，并且内容又被写入到`ls-output.txt`。因此，这条命令可以做到重定向标准输出和错误到同一个文件）

（6）**处理不必要的输出：**
- `ls -l /bin/usr 2> /dev/null`（这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理）

（7）**标准输入重定向：**
``cat filename``会显示文件的内容，经常被用来显示简短的文本文件。因为`cat`可以接受不只一个文件作为参数，所以它也可以用来**把文件连接在一起**。比方说我们下载了一个大型文件，这个文件被分离成多个部分（USENET中的多媒体文件经常以这种方式分离），我们想把它们连起来。如果文件命名为：movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099...，则可以通过
```shell
cat movie.mpeg.0* > movie.mpeg
```
将它们的内容依次连接起来并写入文件movie.mpeg。

当`cat`没有给出任何参数时，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘，因此它正在等待我们输入数据。每当输入回车换行符时，cat 复制标准输入到标准输出，因此我们看到文本行重复出现。（使用`Ctrl-d`告诉标准输入它已经到达文件末尾EOF）。

可以用`cat > filename`将标准输入写入“标准输出所重定向的文件”filename中。同样地，可以用`cat < filename`
“从标准输入所重定向的文件”中读取内容到标准输出（和`cat filename`一致）。

（8）**管道线：**
使用管道操作符`|`（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：``cmd1``的标准输出可以通过管道送至`cmd2`的标准输入——`cmd1 | cmd2`。典型使用场景：
- `ls -l /usr/bin | less`（将`ls`的输出作为`less`的输入）

（9）**过滤器：**
管道线经常用来对数据完成复杂的操作。有时会把几个命令放在一起组成一个管道线，以这种方式使用的命令被称为过滤器。**过滤器接受输入，以某种方式改变它，然后输出它**。
- `ls /bin /usr/bin | sort | less`（将两个目录的输出结果（有序列表）用`sort`排序后作为`less`的输入）

`uniq`命令经常和`sort`命令结合在一起使用。`uniq`从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。如果只想看到重复的数据列表，使用`-d`选项。

`wc filename`打印出三个数字：包含在文件filename中的行数，单词数和字节数。`-l`选项限制命令输出只能报道行数。
- `ls /bin /usr/bin | sort | uniq | wc -l`（统计两个目录下不同的文件的个数）


（10）**打印匹配行：**
使用`grep·可以找到文件中的匹配文本。使用方式为：
```shell
grep pattern [file ...]
```
当`grep`遇到一个文件中的匹配**模式**，它会打印出包含这个类型的行。`grep`能够匹配的模式可以很复杂（通过正则表达式实现）。显然，可以通过管道传递其所需要的输入（即`[file ...]`）。`grep`的选项：`-i`使得`grep`在执行搜索时忽略大小写（通常搜索是大小写敏感的），`-v`选项会告诉`grep`只打印不匹配的行。

（11）**使用`tee`捕捉管道线内容**：
从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）**和一个或多个文件**。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。
- `ls /usr/bin | tee ls.txt | grep zip`（将`ls`的输出在使用``grep``过滤之前先写入文件`ls.txt`中，与此同时，因为`ls`的输出也会被复制到标准输出，因此会作为`grep`的输入，从而将过滤结果打印到标准输出上）

13、模式展开，神秘和混乱的源泉

（1）在shell内输入一个命令之后，在执行命令前，shell首先会对其进行**字符展开**（回忆通配符`*`的丰富含义）。

（2）传递到`echo`命令的任一个参数都会在（屏幕上）显示出来。通配符所依赖的工作机制叫做**路径名展开**。结合通配符，我们可以使用`echo *`展示出当前目录下的所有文件（及目录）。其他类似的例子：
- `echo .*`（显示所有隐藏文件）
- `echo .[!.]?*`（在显示所有隐藏文件的基础上不显示`.`和`..`）

（3）使用`$((exper))`做**算术表达式的展开**（算术表达式仅支持整型数字）。因此可以使用`echo $((exper))`返回算术表达式的运算结果。

（4）**花括号展开**：从一个包含花括号的模式中创建多个文本字符串。花括号表达式本身可能包含：
* 一个逗号分开的字符串列表（不要加上空格），e.g.：`{A,B,C}`
* 一个整数区间，e.g.：`{1..10}`
* 一个字符区间，e.g.：`{A..Z}`

花括号的展开可以嵌套：
```shell
(base) ➜  playground echo before-{A{1..3},B{a..b}}-end
before-A1-end before-A2-end before-A3-end before-Ba-end before-Bb-end
```
**通过花括号展开，我们可以创建、移动或删除一系列文档。这比GUI操作快多了。**

（5）**波浪线展开**：波浪线`~`代表当前用户的home目录。

（6）**参数展开**（用**变量展开**更好理解一点）：使用`echo $VAR_NAME`对变量`VAR_NAME`进行展开，这在shell脚本中非常实用。常用例子：
- `echo $USER`（显示当前用户名）
- `echo $HOST`（显示当前主机名）
- `echo $PATH`（显示全部命令的搜索目录）

使用`printenv`查看有效的变量。如果拼错了变量名，则展开得到空字符串。

（7）**命令替换**：通过`echo $(cmd)`把一个命令的输出作为展开模式来使用。例如，可以用`ls -l $(which python)`来显示当前`python`的版本。命令当然他也可以很复杂，如：
```shell
(base) ➜  ~ file $(ls /usr/local/bin/* | grep kube)
/usr/local/bin/kubectl:        Mach-O 64-bit executable x86_64
/usr/local/bin/kubectl.docker: Mach-O 64-bit executable x86_64
```

（8）**引用**：<br>
首先分析一下输出：
- `echo this is  a  test`（输出`this is a test`，shell会利用**单词分割**删除掉参数列表中多余的空格。在默认情况下，单词分割机制会在单词中寻找**空格，制表符，和换行符**，并把它们看作单词之间的界定符。这意味着“无引用”的空格，制表符和换行符都不是文本的一部分，它们只作为分隔符使用（对单个字符的引用通过转义字符`\`实现）。由于它们把单词分为不同的参数，所以在上面的例子中，命令行包含一个带有四个不同参数的命令）
- `echo total num: $100.00 xyz`（macOS下输出`total num: .00 xyz`，这是因为`$100`被解读为变量引用，但是不存在名为`100`的变量，因此展开得到空字符串）

（8.1）**使用双引号禁用单词分割**：

假设当前目录下存在名为`my test.txt`的文件，使用`ls -l my test.txt`会将单词分割为`my`和`test.txt`，结果显示两个文件均未找到。使用`ls -l "my test.txt"`则可得到期望的结果（这也解释了为什么文件命名时尽量不要使用空格）。

总结：如果把文本放在双引号中，shell使用的特殊字符都失去它们的特殊含义，被当作普通字符来看待。但是有几个例外：`$`，`\` (转义字符），和`\``（倒引号）。这意味着**单词分割、路径名展开、波浪线展开和花括号展开**都将失效，然而**参数展开、算术展开和命令替换**仍然执行。

单词分割机制带来的有趣现象：
```shell
(base) ➜  ~ echo $(cal)
January 2021 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
(base) ➜  ~ echo "$(cal)"
    January 2021
Su Mo Tu We Th Fr Sa
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
31
```
前者，因为单词分割机制，`$(cal)`被展开成包含40个参数的列表，`echo`命令将删除多余的界定符；后者，因为`$(cal)`被禁用展开，因此得到的是包含了多个空格、换行符、制表符的单个参数，被`echo`原样输出。

（8.2）**使用单引号禁用所有展开**：
```shell
(base) ➜  ~ echo text .l* {a,b} $(echo foo) $((2+2)) $USER
text .lesshst .lldb .local a b foo 4 hliangzhao
(base) ➜  ~ echo "text .l* {a,b} $(echo foo) $((2+2)) $USER"
text .l* {a,b} foo 4 hliangzhao
(base) ➜  ~ echo 'text .l* {a,b} $(echo foo) $((2+2)) $USER'
text .l* {a,b} $(echo foo) $((2+2)) $USER
```

（8.3）**使用`\`对单个字符进行转义**：
```shell
(base) ➜  playground echo money: \$5.00
money: $5.00
(base) ➜  playground echo "money: \$5.00"
money: $5.00
(base) ➜  playground echo 'money: \$5.00'
money: \$5.00
```
上述例子想要单纯地引用“美元符号”。注意，单引号中，所有展开都将失效。因此单个字符的转义也失效。下面这个例子中，我们想要单纯地引用空格符，<font color=red>然而它是作为**路径名展开**被使用的，因此双引号即可让转义失效【存疑】</font>。
```shell
(base) ➜  playground ls -l my\ file.txt
-rw-r--r--@ 1 hliangzhao  staff  0 Jan 24 13:54 my file.txt
(base) ➜  playground ls -l "my\ file.txt"
ls: my\ file.txt: No such file or directory
(base) ➜  playground ls -l 'my\ file.txt'
ls: my\ file.txt: No such file or directory
```

（8.4）**使用`\`表示特殊字符（控制码）**：
| 转义序列 | 含义
| --- | ---
| `\a` | 响铃（”警告”－导致计算机嘟嘟响）
| `\b` | 退格符
| `\n` | 新的一行。在类 Unix 系统中，产生换行。
| `\r` | 回车符
| `\t` | 制表符
默认情况下，`\`被解释为对单个字符的转义，因此如果想用`\`表示控制码，需使用引号