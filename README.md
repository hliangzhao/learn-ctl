## Learning Linux Command Line
### 一、要点
1、一个类Unix的操作系统以**分层目录结构**来组织所有文件，组成了一棵树形目录。
类Unix的操作系统只有一个单一的文件系统树，不管有多少个磁盘或者存储设备连接到计算机上。
根据负责维护系统安全的系统管理员的兴致，存储设备**挂载**到（mount）目录树的各个节点上。

2、Linux没有“文件扩展名”的概念，可以用任何名字来给文件起名。文件内容或用途由其它方法来决定。

3、相关命令：``pwd``，``cd``，``ls``，``file``（确定文件类型），``less``（浏览文件内容）、`rm`、`cp`、`mv`、`mkdir`、`ln`（创建硬链接和符号链接）。

4、``ls``命令记不住的选项：
|  选项  | 描述
|  ---- | ----
| `-d, --directory` | 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。
| ``-h, --human-readable`` | 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。
| ``-S``  | 命令输出结果按照文件大小来排序。
| ``-t``  | 按照修改时间来排序。

5、``ls -a``的输出格式中，第二个表示文件硬链接的个数。
```
-rw-r--r--@  1 hliangzhao  staff   1.6K Jan 17 10:20 .bash_profile
```

6、什么是**文本**（text）？
在计算机中，信息的表达与记录是通过映射到数字来实现的。**文本**是简单的字符与数字之间的一对一映射。五十个字符的文本翻译成五十个字节的数据。纯ASCII文件只包含字符本身和一些基本的控制符（如制表符、回车符及换行符等）。相反，如``.docx``这样的文字处理器文档包含许多非文本元素，来描述它的结构和格式。

在Linux系统中，大多数系统配置文件和脚本文件都是文本文件。

7、Linux系统目录

| 目录 | 描述
| --- | ---
| ``/bin`` | 包含系统启动和运行所必须的二进制程序。
| ``/boot`` | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。
|  ``/dev`` | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。
| ``/etc`` | 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。<br> <ui><li>``/etc/crontab``：定义自动运行的任务。</li><li>`/etc/fstab`：包含存储设备的列表，以及与他们相关的挂载点。</li><li>`/etc/passwd`：包含用户帐号列表。</li></ui>
| ``/home``| 在通常的配置环境下，系统会在\/home`下，给每个用户分配一个目录。普通用户只能在自己的目录下**写**文件。这个限制保护系统免受错误的用户活动破坏。 | 
| ``/lib`` | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。
| ``/media`` | （现代Linux）包含**可移动介质**的挂载点， 例如USB驱动器，CD-ROMs等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。
| ``/mnt`` | （早期Linux）包含可移动介质的挂载点。
| ``/opt`` | 被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。
| ``/proc`` | 从存储在硬盘上的文件的意义上说，它不是真正的文件系统。相反，它是一个由Linux内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的，它们会告诉你内核是怎样监管计算机的。
| ``/root`` | root账户的home directory。
| ``/tmp`` | 用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次重新启动时，都会清空这个目录。
| ``/usr`` | 包含普通用户所需要的所有程序和文件（User System Resource）。
| ``/usr/bin`` | 包含系统安装的可执行程序。通常，这个目录会包含许多程序。
| ``/usr/lib`` | 包含由/usr/bin 目录中的程序所用的共享库。
| ``/usr/local`` | 这是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在``/usr/local/bin``目录下。新安装的Linux系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。
| ``/usr/sbin`` | 包含许多系统管理程序（system binary）。
| ``/usr/share`` | 包含许多由``/usr/bin``目录中的程序使用的共享数据。其中包括像默认的配置文件、图标、桌面背景、音频文件等等。
| ``/usr/share/doc`` | 大多数安装在系统中的软件包会包含一些文档。在该目录我们可以找到按照软件包分类的文档。
| ``/var`` | 除了``/tmp``和``/home``目录之外，相对来说，目前我们看到的目录是静态的，这是说，它们的内容不会改变。``/var``目录存放的是动态文件。各种数据库、假脱机文件、用户邮件等等，都位于在这里。
| ``/var/log`` | 包含日志文件、各种系统活动的记录。这些文件非常重要，并且应该时时监测它们。其中最重要的一个文件是``/var/log/messages``。注意，为了系统安全，在一些系统中，你必须是超级用户才能查看这些日志文件。

8、通配符：这是shell提供的特殊字符，用来帮助我们快速指定一组文件名。接受文件名作为参数的任何命令，都可以使用通配符。

| 通配符 | 意义
| --- | --- 
| `*` | 匹配任意多个字符（包括零个或一个）
| `?` | 匹配任意一个字符（不包括零个）
| `[characters]` | 匹配任意一个属于**字符集**中的字符
| `[!characters]` | 匹配任意一个不是字符集中的字符
| `[[:class:]]` | 匹配任意一个属于**指定字符类**中的字符

常用的字符类有：
| 字符类 | 意义
| --- | ---
| `[:alnum:]` | 匹配任意一个字母或数字
| `[:alpha:]` | 匹配任意一个字母
| `[:digit:]` | 匹配任意一个数字
| `[:lower:]` | 匹配任意一个小写字母
| `[:upper:]` | 匹配任意一个大写字母

通配符的案例：
| 模式 | 匹配对象
| --- | ---
| `*` | 所有文件
| `g*` | 文件名以“g”开头的文件
| `b*.txt` | 以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件
| `Data???` | 以“Data”开头，其后紧接着3个字符的文件
| `[abc]*` | 文件名以"a","b",或"c"开头的文件
| `BACKUP.[0-9][0-9][0-9]` | 以"BACKUP."开头，并紧接着3个数字的文件
| `[[:upper:]]*` | 以大写字母开头的文件
| `[![:digit:]]*` | 不以数字开头的文件
| `*[[:lower:]123]` | 文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件

9、`cp`的参数：
选项 | 意义
--- | ---
`-a, --archive` | 复制文件和目录，**以及它们的属性**，包括拥有者和所有权。 通常，副本具有用户所操作文件的默认属性。
`-i, --interactive` | 在重写已存在文件之前，提示用户确认。如果这个选项不指定， `cp`命令会默认重写文件。
`-r, --recursive` | 递归地复制目录及目录中的内容。当复制目录时，需要这个选项（或者`-a`选项）。
`-u, --update` | 当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。
`-v, --verbose` | 显示翔实的命令操作信息

`cp`、`mv`、`rm`、`mkdir`等均可用`-v`参数来输出帮助命令。用`man/info command`来查阅更为全面详细的命令参数信息。

10、硬链接与符号链接：

**硬链接**是最初Unix创建链接的方式。每个文件默认会有一个硬链接，这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目录项。硬链接有两个重要局限性：
- 一个硬链接不能关联它所在文件系统之外的文件（不能关联与链接本身不在同一个磁盘分区上的文件）。
- 一个硬链接不能关联一个目录。

**符号链接**生效，是通过创建一个 特殊类型的文件，这个文件包含一个关联文件或目录的文本指针（类似“快捷方式”）。对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。 而`rm`命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。

``ls -i``可显示文件索引节点号（index），索引节点相同则表示是同一个文件。

10、什么是命令？

- 是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 这一类程序可以是用诸如 C 和 C++语言写成的程序编译的二进制文件, 也可以是由诸如shell，perl，python，ruby等等脚本语言写成的程序 。
- 是一个内建于shell自身的命令。bash支持若干命令，内部叫做shell内部命令 (builtins)。例如，`cd`、`mv`等。
- 是一个 shell 函数。
- 是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。

用以下命令查阅和理解命令：
* `type` – 说明怎样解释一个命令名
* `which` – 显示会执行哪个可执行程序（只对可执行程序有效，不包括内建命令和命令别名）
* `man` – 显示命令手册页
* `apropos` – 显示一系列适合的命令
* `info` – 显示命令
* `whatis` – 显示一个命令的简洁描述
* `alias` – 创建命令别名（e.g.，`alias foo='cd /usr; ls; cd -'，unalias foo`），仅在shell会话内有效。

11、**重定向**

（1）**常用命令**
- `cat` － 连接/显示文件
- `sort` － 排序文本行
- `uniq` － 报道或省略重复行
- `grep` － 打印匹配行
- `wc` － 打印文件中换行符，字，和字节个数
- `head` － 输出文件第一部分
- `tail` - 输出文件最后一部分
- `tee` - 从标准输入读取数据，并同时写到标准输出和文件

（2）与Unix主题“任何东西都是一个文件”保持一致，像`ls`这样的程序实际上把他们的运行结果输送到一个叫做**标准输出**的特殊文件（`stdout`），而它们的状态信息则送到另一个叫做**标准错误**的文件（`stderr`）。默认情况下，标准输出和标准错误都连接到屏幕。除此之外，许多程序从一个叫做标准输入（`stdin`）的设备得到输入，默认情况下，标准输入连接到键盘。I/O 重定向允许我们更改输出地点和输入来源。一般来说，输入来自键盘，输出送到屏幕，但是通过I/O重定向，我们可以做出改变。

（3）**标准输出重定向：**使用“>”*重定向符后接文件名*将标准输出重定向到屏幕以外的一个文件（没错！屏幕也可以视为一个文件）。当我们使用“>”重定向符来重定向输出结果时，目标文件总是从开头被重写。如果命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后由于错误而停止，导致文件内容清空。使用”>>“重定向符将命令的输出追加到重定向文件。
- `ls -l /usr/bin > ls-output.txt`（重写）
- `ls -l /usr/bin >> ls-output.txt`（追加）

（4）**标准错误重定向：**文件流的前三个称作标准输入、输出和错误，shell内部分别将其称为文件描述符0、1和2。
- `ls -l /bin/usr 2> ls-error.txt`（如果命令有错误，则写入文件，否则文件为空）

（5）**重定向标准输出和错误到同一个文件：**
- `ls -l /bin/usr > ls-output.txt 2>&1`（首先重定向标准输出到文件ls-output.txt，然后重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法`2>&1`。如果没出错，则标准错误为空，因此`ls-output.txt`不会被追加任何信息；如果出错了，则一开始`ls-output.txt`为空，但是标准错误不为空，并且内容又被写入到`ls-output.txt`。因此，这条命令可以做到重定向标准输出和错误到同一个文件）

（6）**处理不必要的输出：**
- `ls -l /bin/usr 2> /dev/null`（这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理）

（7）**标准输入重定向：**
``cat filename``会显示文件的内容，经常被用来显示简短的文本文件。因为`cat`可以接受不只一个文件作为参数，所以它也可以用来**把文件连接在一起**。比方说我们下载了一个大型文件，这个文件被分离成多个部分（USENET中的多媒体文件经常以这种方式分离），我们想把它们连起来。如果文件命名为：movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099...，则可以通过
```shell
cat movie.mpeg.0* > movie.mpeg
```
将它们的内容依次连接起来并写入文件movie.mpeg。

当`cat`没有给出任何参数时，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘，因此它正在等待我们输入数据。每当输入回车换行符时，cat 复制标准输入到标准输出，因此我们看到文本行重复出现。（使用`Ctrl-d`告诉标准输入它已经到达文件末尾EOF）。

可以用`cat > filename`将标准输入写入“标准输出所重定向的文件”filename中。同样地，可以用`cat < filename`
“从标准输入所重定向的文件”中读取内容到标准输出（和`cat filename`一致）。

（8）管道线：``cmd1``的标准输出可以通过管道送至`cmd2`的标准输入——`cmd1 | cmd2`。

