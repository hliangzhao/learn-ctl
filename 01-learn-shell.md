## 学习shell
- [学习shell](#学习shell)
  - [文件](#文件)
  - [命令](#命令)
  - [字符展开](#字符展开)
  - [权限管理](#权限管理)
  - [进程](#进程)
### 文件
1、一个类Unix的操作系统以**分层目录结构**来组织所有文件，组成了一棵“文件系统树”。
类Unix的操作系统只有一个**单一**的文件系统树，不管有多少个磁盘或者存储设备连接到计算机上。
存储设备可以**挂载**（mount）到文件系统数的任意节点上。

2、Linux没有“文件扩展名”的概念，可以用任何名字来给文件起名。文件内容或用途由使用此文件的程序来决定。

3、需要熟练掌握的命令：
- ``pwd``：print working directory
- ``cd``：change directory
- ``ls``：list directory
- ``file``：确定文件类型
- ``less``浏览文件内容
- `rm`：remove
- `cp`：copy
- `mv`、move
- `mkdir`：make directory
- `ln`：创建硬链接和符号链接

**熟练使用`man cmd`阅读命令`cmd`的文档！**
大多数shell内置命令是无法使用`--help`或者`-h`来显示帮助的，这是因为`-h`常常是命令本身的选项之一。取而代之地，使用`cmd -v`显示帮助（verbose）。

4、什么是**文本**（text）？
在计算机中，信息的表达与记录是通过映射到数字来实现的。**文本**是字符与数字之间的一对一映射。纯ASCII文件只包含字符本身和一些基本的控制符（如制表符、回车符及换行符等）。而如``.docx``这样的文字处理器文档则包含许多非文本元素来描述它的结构和格式。

5、**在Linux系统中，大多数系统配置文件和脚本文件都是文本文件。**

6、Linux系统目录：

| 目录 | 描述
| --- | ---
| ``/bin`` | 包含系统启动和运行所必须的二进制程序。
| ``/boot`` | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。
|  ``/dev`` | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。
| ``/etc`` | 这个目录包含所有系统层面的配置文件。它也包含一系列的shell脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。<br> <ui><li>``/etc/crontab``：定义自动运行的任务。</li><li>`/etc/fstab`：包含存储设备的列表，以及与他们相关的挂载点。</li><li>`/etc/passwd`：包含用户帐号列表。</li></ui>
| ``/home``| 在通常的配置环境下，系统会在`/home`下，给每个用户分配一个目录。普通用户只能在自己的目录下**写**文件。这个限制保护系统免受错误的用户活动破坏。 | 
| ``/lib`` | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。
| ``/media`` | （现代Linux中）包含**可移动介质**的挂载点， 例如USB驱动器，CD-ROMs等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。
| ``/mnt`` | （早期Linux中）包含可移动介质的挂载点。
| ``/opt`` | 被用来安装“可选的”软件。这个主要用来存储可能安装在系统中的商业软件产品。
| ``/proc`` | 从存储在硬盘上的文件的意义上说，它不是真正的文件系统。相反，它是一个由Linux内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的，它们会告诉你内核是怎样监管计算机的。
| ``/root`` | root账户的home directory。
| ``/tmp`` | 用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次重新启动时，都会清空这个目录。
| ``/usr`` | 包含普通用户所需要的所有程序和文件（User System Resource）。
| ``/usr/bin`` | 包含系统安装的可执行程序。通常，这个目录会包含许多程序。
| ``/usr/lib`` | 包含由`/usr/bin`目录中的程序所用的共享库。
| ``/usr/local`` | 这是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在``/usr/local/bin``目录下。新安装的Linux系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。
| ``/usr/sbin`` | 包含许多系统管理程序（system binary）。
| ``/usr/share`` | 包含许多由``/usr/bin``目录中的程序使用的共享数据。其中包括像默认的配置文件、图标、桌面背景、音频文件等等。
| ``/usr/share/doc`` | 大多数安装在系统中的软件包会包含一些文档。在该目录我们可以找到按照软件包分类的文档。
| ``/var`` | 除了``/tmp``和``/home``目录之外，相对来说，目前我们看到的目录是静态的，这是说，它们的内容不会改变。``/var``目录存放的是动态文件。各种数据库、假脱机文件、用户邮件等等，都位于在这里。
| ``/var/log`` | 包含日志文件、各种系统活动的记录。这些文件非常重要，并且应该时时监测它们。其中最重要的一个文件是``/var/log/messages``。注意，为了系统安全，在一些系统中，你必须是超级用户才能查看这些日志文件。
<br>

7、**通配符**：这是shell提供的特殊字符，用来帮助我们快速指定一组文件名。**接受文件名作为参数的任何命令，都可以使用通配符。**

| 通配符 | 意义
| --- | --- 
| `*` | 匹配任意多个字符（包括零个或一个）
| `?` | 匹配任意一个字符（不包括零个）
| `[characters]` | 匹配任意一个属于**字符集**中的字符
| `[!characters]` | 匹配任意一个不是字符集中的字符
| `[[:class:]]` | 匹配任意一个属于**指定字符类**中的字符
<br>

常用的字符类有：
| 字符类 | 意义
| --- | ---
| `[:alnum:]` | 匹配任意一个字母或数字
| `[:alpha:]` | 匹配任意一个字母
| `[:digit:]` | 匹配任意一个数字
| `[:lower:]` | 匹配任意一个小写字母
| `[:upper:]` | 匹配任意一个大写字母
<br>

通配符的案例：
| 模式 | 匹配对象
| --- | ---
| `*` | 所有文件
| `g*` | 文件名以“g”开头的文件
| `b*.txt` | 以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件
| `Data???` | 以“Data”开头，其后紧接着3个字符的文件
| `[abc]*` | 文件名以"a","b",或"c"开头的文件
| `BACKUP.[0-9][0-9][0-9]` | 以"BACKUP."开头，并紧接着3个数字的文件
| `[[:upper:]]*` | 以大写字母开头的文件
| `[![:digit:]]*` | 不以数字开头的文件
| `*[[:lower:]123]` | 文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件
<br>

8、硬链接与符号链接：

**硬链接**是最初Unix创建链接的方式。每个文件默认会有一个硬链接，这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目录项。硬链接有两个重要局限性：
- 一个硬链接不能关联它所在文件系统之外的文件（不能关联与链接本身不在同一个磁盘分区上的文件）。
- 一个硬链接不能关联一个目录。

**符号链接**生效，是通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的文本指针（类似“快捷方式”）。**对于符号链接，执行的大多数文件操作是针对链接的对象，而不是链接本身。 而`rm`命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。**

``ls -i``可显示文件索引节点号（index），索引节点相同则表示是同一个文件。通过这个命令可以发现同一个文件的多个链接和文件本身都拥有相同的节点号。

### 命令
9、什么是命令？

- 是一个可执行程序，就像我们所看到的位于目录`/usr/bin`中的文件一样。 这一类程序可以是用诸如C和C++语言写成的程序编译的二进制文件，也可以是由诸如shell，perl，python，ruby等等脚本语言写成的、由解释器解释运行的脚本文件。
- 是一个内建于shell自身的命令。bash支持若干命令，内部叫做shell内部命令（builtins）。例如，`cd`、`pwd`、`kill`等。
- 是一个shell函数。
- 是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。

用以下命令查阅和理解命令：
* `type` – 说明怎样解释一个命令名
* `which` – 显示会执行哪个可执行程序（只对可执行程序有效，不包括内建命令和命令别名）
* `man` – 显示命令手册页
* `apropos` – 显示一系列适合的命令
* `info` – 显示命令
* `whatis` – 显示一个命令的简洁描述
* `alias` – 创建命令别名（e.g.，`alias foo='cd /usr; ls; cd - > /dev/null'，unalias foo`），仅在shell会话内有效。如果想要持久生效，可将其写入`.bash_profile`等启动时会读取的配置文件中。

10、**重定向**

（1）常用命令
- `cat` － 连接/显示文件
- `sort` － 排序文本**行**
- `uniq` － 报道或省略重复行
- `grep` － 打印匹配行
- `wc` － 打印文件中换行符、字、字节个数
- `head` － 输出文件第一部分（`-n num`将将默认输出的行数设置为num）
- `tail` - 输出文件最后一部分（同上）
- `tee` - **从标准输入读取数据，并同时写到标准输出和文件**

（2）与Unix主题“任何东西都是一个文件”保持一致，像`ls`这样的程序实际上把他们的运行结果输送到一个叫做**标准输出**的特殊文件（`stdout`），而它们的状态信息则送到另一个叫做**标准错误**的文件（`stderr`）。默认情况下，标准输出和标准错误都连接到屏幕。除此之外，许多程序从一个叫做标准输入（`stdin`）的设备得到输入，默认情况下，标准输入连接到键盘。I/O 重定向允许我们更改输出地点和输入来源。一般来说，输入来自键盘，输出送到屏幕，但是通过I/O重定向，我们可以做出改变。

（3）**标准输出重定向：**

使用`>`（重定向符后接文件名）将标准输出重定向到一个指定文件。当我们使用`>`重定向符来重定向输出结果时，目标文件总是**从开头被重写**。如果命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后由于错误而停止，导致文件内容清空。使用`>>`重定向符将命令的输出追加到重定向文件。
- `ls -l /usr/bin > ls-output.txt`（重写）
- `ls -l /usr/bin >> ls-output.txt`（追加）

（4）**标准错误重定向：**

文件流的前三个称作标准输入、输出和错误，shell内部分别将其称为文件描述符0、1和2。
- `ls -l /bin/usr 2> ls-error.txt`（如果命令有错误，则将标准输出重定向到文件`ls-error.txt`，否则不改变标准输出）

（5）**重定向标准输出和错误到同一个文件：**
- `ls -l /bin/usr > ls-output.txt 2>&1`：首先重定向标准输出到文件`ls-output.txt`，然后重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法`2>&1`。如果没出错，则标准错误为空，因此`ls-output.txt`不会被追加任何信息；如果出错了，则一开始`ls-output.txt`为空，但是标准错误不为空，并且内容又被写入到`ls-output.txt`。因此，这条命令可以做到重定向标准输出和错误到同一个文件。更为简单的写法是`ls -l /bin/usr &> ls-output.txt`。

（6）**处理不必要的输出：**
- `ls -l /bin/usr 2> /dev/null`（文件`/dev/null`是系统设备，叫做位存储桶，它可以接受输入，并且对输入不做任何处理）

（7）**标准输入重定向：**

``cat filename``会显示文件的内容，经常被用来显示简短的文本文件。因为`cat`可以接受不只一个文件作为参数，所以它也可以用来**把文件连接在一起**。比方说我们下载了一个大型文件，这个文件被分离成多个部分（USENET中的多媒体文件经常以这种方式分离），我们想把它们连起来。如果文件命名为：movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099...，则可以通过
```shell
cat movie.mpeg.0* > movie.mpeg
```
将它们的内容依次连接起来并写入文件movie.mpeg。

当`cat`没有给出任何参数时，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘，因此它正在等待我们输入数据。每当输入回车换行符时，cat 复制标准输入到标准输出，因此我们看到文本行重复出现。（使用`Ctrl-d`告诉标准输入它已经到达文件末尾EOF）。

可以用`cat > filename`将标准输入写入“标准输出所重定向的文件”filename中。同样地，可以用`cat < filename`
“从标准输入所重定向的文件”中读取内容到标准输出（和`cat filename`一致）。

（8）**管道线：**

使用管道操作符`|`（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：``cmd1``的标准输出可以通过管道送至`cmd2`的标准输入——`cmd1 | cmd2`。典型使用场景：
- `ls -l /usr/bin | less`（将`ls`的输出作为`less`的输入）

（9）**过滤器：**

管道线经常用来对数据完成复杂的操作。有时会把几个命令放在一起组成一个管道线，以这种方式使用的命令被称为过滤器。**过滤器接受输入，以某种方式改变它，然后输出它**。
- `ls /bin /usr/bin | sort | less`（将两个目录的输出结果（有序列表）用`sort`排序后作为`less`的输入）

`uniq`命令经常和`sort`命令结合在一起使用。`uniq`从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。如果只想看到重复的数据列表，使用`-d`选项。

`wc filename`打印出三个数字：包含在文件filename中的行数，单词数和字节数。`-l`选项限制命令输出只能报道行数。
- `ls /bin /usr/bin | sort | uniq | wc -l`（统计两个目录下不同的文件的个数）

（10）**打印匹配行：**

使用`grep`可以找到文件中的匹配文本。使用方式为：
```shell
grep pattern [file ...]
```
当`grep`遇到一个文件中的匹配**模式**，它会打印出包含这个类型的行。`grep`能够匹配的模式可以很复杂（通过正则表达式实现）。显然，可以通过管道传递其所需要的输入（即`[file ...]`）。`grep`的选项：`-i`使得`grep`在执行搜索时忽略大小写（通常搜索是大小写敏感的），`-v`选项会告诉`grep`只打印不匹配的行。

（11）**使用`tee`捕捉管道线内容：**

从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）**和一个或多个文件**。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。
- `ls /usr/bin | tee ls.txt | grep zip`（将`ls`的输出在使用``grep``过滤之前先写入文件`ls.txt`中，与此同时，因为`ls`的输出也会被复制到标准输出，因此会作为`grep`的输入，从而将过滤结果打印到标准输出上）

### 字符展开
11、**字符展开**

（1）在shell内输入一个命令之后，在执行命令前，shell首先会对其进行**字符展开**。

（2）使用`echo`进行回显：传递到`echo`命令的任一个参数都会在（屏幕上）显示出来。通配符所依赖的工作机制叫做**路径名展开**。结合通配符，我们可以使用`echo *`展示出当前目录下的所有文件（及目录）。其他类似的例子：
- `echo .*`（显示所有隐藏文件）
- `echo .[!.]?*`（在显示所有隐藏文件的基础上不显示`.`和`..`）

（3）使用`$((exper))`做**算术表达式的展开**（算术表达式仅支持整型数字）。因此可以使用`echo $((exper))`返回算术表达式的运算结果。

（4）**花括号展开：**从一个包含花括号的模式中创建多个文本字符串。花括号表达式本身可能包含：
* 一个逗号分开的字符串列表（不要加上空格），e.g.：`{A,B,C}`
* 一个整数区间，e.g.：`{1..10}`
* 一个字符区间，e.g.：`{A..Z}`

花括号的展开可以嵌套：
```shell
(base) ➜  playground echo before-{A{1..3},B{a..b}}-end
before-A1-end before-A2-end before-A3-end before-Ba-end before-Bb-end
```
**通过花括号展开，我们可以创建、移动或删除一系列文档。这比GUI操作快多了。**

（5）**波浪线展开：**波浪线`~`代表当前用户的home目录。

（6）**参数展开：**（用**变量展开**更好理解一点）使用`echo $VAR_NAME`对变量`VAR_NAME`进行展开，这在shell脚本中非常实用。常用例子：
- `echo $USER`（显示当前用户名）
- `echo $HOST`（显示当前主机名）
- `echo $PATH`（显示全部命令的搜索目录）

使用`printenv`查看有效的变量。如果拼错了变量名，则展开得到空字符串。

（7）**命令替换：**通过`echo $(cmd)`把一个命令的输出作为展开模式来使用。例如，可以用`ls -l $(which python)`来显示当前`python`的版本。命令当然他也可以很复杂，如：
```shell
(base) ➜  ~ file $(ls /usr/local/bin/* | grep kube)
/usr/local/bin/kubectl:        Mach-O 64-bit executable x86_64
/usr/local/bin/kubectl.docker: Mach-O 64-bit executable x86_64
```

（8）**引用：**
首先分析一下输出：
- `echo this is  a  test`（输出`this is a test`，shell会利用**单词分割**删除掉参数列表中多余的空格。在默认情况下，单词分割机制会在单词中寻找**空格，制表符，和换行符**，并把它们看作单词之间的界定符。这意味着“无引用”的空格，制表符和换行符都不是文本的一部分，它们只作为分隔符使用（对单个字符的引用通过转义字符`\`实现）。由于它们把单词分为不同的参数，所以在上面的例子中，命令行包含一个带有四个不同参数的命令）
- `echo total num: $100.00 xyz`（macOS下输出`total num: .00 xyz`，这是因为`$100`被解读为变量引用，但是不存在名为`100`的变量，因此展开得到空字符串）

（8.1）**使用双引号禁用单词分割和部分展开**：

假设当前目录下存在名为`my test.txt`的文件，使用`ls -l my test.txt`会将单词分割为`my`和`test.txt`，结果显示两个文件均未找到。使用`ls -l "my test.txt"`则可得到期望的结果（这也解释了为什么文件命名时尽量不要使用空格）。

总结：如果把文本放在双引号中，shell使用的特殊字符都失去它们的特殊含义，被当作普通字符来看待。但是有几个例外：`$`，`\` (转义字符），和倒引号。
**使用双引号后，单词分割、路径名展开、波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换（这三者均依赖于`$`）仍然执行。**

单词分割机制带来的有趣现象：
```shell
(base) ➜  ~ echo $(cal)
January 2021 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
(base) ➜  ~ echo "$(cal)"
    January 2021
Su Mo Tu We Th Fr Sa
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
31
```
前者，因为单词分割机制，`$(cal)`被展开成包含40个参数的列表，`echo`命令将删除多余的界定符；后者，因为`$(cal)`被禁用展开，因此`echoe`得到的是包含了多个空格、换行符、制表符的单个参数，被`echo`原样输出。

（8.2）**使用单引号禁用所有展开**：
```shell
(base) ➜  ~ echo text .l* {a,b} $(echo foo) $((2+2)) $USER
text .lesshst .lldb .local a b foo 4 hliangzhao
(base) ➜  ~ echo "text .l* {a,b} $(echo foo) $((2+2)) $USER"
text .l* {a,b} foo 4 hliangzhao
(base) ➜  ~ echo 'text .l* {a,b} $(echo foo) $((2+2)) $USER'
text .l* {a,b} $(echo foo) $((2+2)) $USER
```

（8.3）**转义字符`\`**：
有一些字符对shell而言有特殊含义，如`$`、`!`、`\`等，它们默认情况下会被展开。但是，有时候我们并不想使用这些字符的特殊含义，而只想引用这些字符本身（例如，只想将`$`理解为美元符号），就可以通过转义字符`\`来消除这些字符的特殊含义。
```shell
(base) ➜  playground echo money: \$5.00    # 消解参数展开
money: $5.00
(base) ➜  playground echo "money: \$5.00"  # 消解参数展开（双引号不会影响`\`工作）
money: $5.00
(base) ➜  playground echo 'money: \$5.00'  # 失效（单引号会影响`\`工作）
money: \$5.00
```
将`\`放在普通字符前，

（8.4）**控制码**：
虽然`\`可以被用来当作转义字符来消除特殊字符的特殊含义，但是有些特殊字符在表达本身的时候就需要用到`\`，以下给出了一些例子：
| 转义序列 | 含义
| --- | ---
| `\a` | 响铃（”警告”－导致计算机嘟嘟响）
| `\b` | 退格符
| `\n` | 新的一行。在类 Unix 系统中，产生换行。
| `\r` | 回车符
| `\t` | 制表符

这些特殊字符被称为**控制码**。
- 不加双引号或单引号时，`\`被解读为对单个字符的转义。如果待转义字符是普通字符（既不需要转义），那么`\`会被无视，剩余部分原样输出；如果该单个字符本身的确是特殊字符如`!`或`$`或`\`等，则输出成功转义后的结果。
- 加上双引号时，如果引号内是一个控制码，则被shell当作控制码，否则仍然解读为对单个字符的转义。如果待转义的是普通字符（既不需要转义），那么`\`**不会**被无视，引号内的部分**全体原样输出**；如果该单个字符本身的确是特殊字符如`!`或`$`或`\`等，则输出成功转义后的结果。
- 加上单引号时，如果引号内是一个控制码，则被shell当作控制码，否则原样输出（因为“转义”也会被禁用）。

```shell
(base) ➜  playground ls -l my\ file.txt        # 解读为对单个字符“空格”的转义
-rw-r--r--@ 1 hliangzhao  staff  0 Jan 24 13:54 my file.txt
(base) ➜  playground ls -l "my\ file.txt"      # 尝试解读为控制码，但是不存在“\ ”表示的控制码。由于双引号内禁用单词分割，所以对空格的转义也是不必要的，因此原样输出
ls: my\ file.txt: No such file or directory
(base) ➜  playground ls -l 'my\ file.txt'      # 同上
```
```shell
# 对普通字符转义
(base) ➜  scripts git:(main) ✗ echo \l
l
(base) ➜  scripts git:(main) ✗ echo "\l"
\l
(base) ➜  scripts git:(main) ✗ echo '\l'
\l
# 对控制码转义
(base) ➜  scripts git:(main) ✗ echo \tabc
tabc
(base) ➜  scripts git:(main) ✗ echo "\tabc"
	abc
(base) ➜  scripts git:(main) ✗ echo '\tabc'
	abc
# 对特殊字符转义
(base) ➜  scripts git:(main) ✗ echo \$100
$100
(base) ➜  scripts git:(main) ✗ echo "\$100"
$100
(base) ➜  scripts git:(main) ✗ echo '\$100'
\$100
(base) ➜  scripts git:(main) ✗ echo "\$100"\$"\$"'\$'
$100$$\$
```

转义序列也可放在`$''`中（不可转义的字符会原样输出），和上面对比下：
```shell
(base) ➜  playground echo $"\table"   # 和echo "$\table"、echo '$\table'均无区别
$	able
(base) ➜  playground echo $'\table'
	able
(base) ➜  playground echo $'\t'able
	able
```

12、使用`history`可以在标准输出上打印出历史命令。受限于终端的默认设置，条目过长时，早期的记录会被“翻页”。想要看到全部历史命令，一种简洁的方式是`history | less`。配合`grep`也可以对历史命令进行检索。此外，可以用`!line-number`直接调出第`line-number`条历史命令。

### 权限管理
13、**权限**

（1）类Unix操作系统不仅是多任务系统，而且也是多用户系统，即多个用户可以在同一时间使用同一台计算机。如果一台计算机连接到一个网络或者因特网，那么远程用户通过`ssh`（安全shell）可以登录并操纵这台电脑。事实上，远程用户也能运行图形界面应用程序，并且图形化的输出结果会出现在远端的显示器上（比如X Window System）。Linux系统的多用户性能是一种深深地嵌入到了Linux操作系统的设计中的特性。

（2）设定用户权限对保护Linux计算机系统免于崩溃是十分重要的。需要熟练掌握以下命令：
* `id`：显示当前用户的身份信息
* `chmod`：更改文件模式
* `umask`：设置默认的文件权限
* `su`：以另一个用户的身份
* `sudo`：以另一个用户的身份来执行命令
* `chown`：改变文件的所有者
* `chgrp`：改变文件组的所有权
* `passwd`：更改用户密码

用户帐户定义在`/etc/passwd`文件里面，用户组定义在`/etc/group`文件里面。

（3）读取、写入和执行<br>
对于如下所示的文件描述（通过`ls -l`获得），第一个字符串有十个字符。
```shell
-rw-r--r--   1 hliangzhao  staff    6 Jan 23 18:42 file.txt
```
其中，第一个字符表示“文件的类型”，候选项有：
| 属性 | 文件类型
| --- | ---
| `-` | 一个普通文件
| `d` | 一个目录
| `l` | 一个符号链接。注意对于符号链接文件，macOS下显示总是`lrwxr-xr-x`，都是虚拟值。真正的文件属性是指符号链接所指向的文件的属性
| `c` | 一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。比如说终端机或者调制解调器
| `b` | 一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者CD-ROM盘。

剩下九个字符表示文件模式叫做“文件模式”，每三个字符分别代表着文件所有者、文件所有者同组用户和其他用户的读、写、和执行权限。如果没有相应的权限，则对应位置为`-`。

| 属性 | 文件 | 目录
| --- | --- | ---
| `r` | 允许打开并读取文件内容。 | 允许列出目录中的内容，前提是目录必须设置了可执行属性（`x`）。
| `w` | 允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由**所在目录的属性**决定的。| 允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（`x`）。
| `x` | 允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。| 允许进入目录`cd directory`。
<br>

一些案例：
- macOS下创建的目录大多具有`drwxr-xr-x@`的权限。即文件所有者可以访问该目录，并且可以在该目录下新建、重命名、删除文件，其余所有用户只能访问。
- macOS用户自己安装的可执行程序大多具有`-rwxr-xr-x`的权限。

**对于`ls -l`所呈现内容的详细解读，可以阅读`man ls`。**

（4）通过``chmod``命令修改文件或目录的权限（只有文件的所有者或者超级用户才能这样做）。

**八进制数字表示法:**<br>
从`000`到`111`，依次表示`---`到`rwx`，我们用单个`0`到`7`之间的数字即可表示文件所有者、文件所有者同组用户和其他用户的读、写、和执行权限。下面给出了一个例子：
```shell
(base) ➜  playground ls -l file1
-rw-r--r--  1 hliangzhao  staff  2 Jan 23 18:41 file1
(base) ➜  playground chmod 600 file1; ls -l file1
-rw-------  1 hliangzhao  staff  2 Jan 23 18:41 file1
```
**符号表示法**：<br>
格式符合“对某个用户添加/减少/指定某个权限”，用户从`u`、`g`、`o`、`a`中选择，动作分别为`+`、`-`、`=`（只有指定权限可用），权限从`r`、`w`、`x`中选择（此处忽略了一些特殊权限设置选项）。
- `chmod u+x script_name`是为刚编写的脚本文件赋予执行权限。
- `chmod u+x,go=r script_name`：赋予所属用户的执行权限，但其余用户只具有读取权限。

一些特殊权限：
- setuid（八进制`4000`）：当应用到一个可执行文件时，它把有效用户ID从真正的用户（实际运行程序的用户）设置成程序所有者的ID。设想这样的场景：**某个程序由root用户所有，并且设置了setuid位，当一个普通用户运行这个程序时，他便可能拥有了访问本应被禁止的访问的文件和目录的能力**。这是不安全的。
- setgid（八进制`2000`）：这个相似于setuid位，把有效用户组ID从真正的用户组ID更改为文件所有者的组ID。如果设置了一个目录的setgid位，则目录中新创建的文件具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。**对于共享目录来说，当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时，那么设置setgid位很有用处**。
- sticky（八进制`1000`）。这个继承于Unix，在Unix中，它可能把一个可执行文件标志为“不可交换的”。在Linux中，会忽略文件的sticky位，但是如果一个目录设置了sticky位，那么它能阻止用户删除或重命名文件，除非用户是这个目录的所有者，或者是文件所有者，或是超级用户。这个经常用来控制访问共享目录，比方说`/tmp`。

一些案例：
- `chmod u+s prog`：授予程序`prog`setuid权限，得到`-rwsr-xr-x`。
- `chmod g+s dir`：授予目录`dir`setgid权限，得到`drwxrwsr0x`。
- `chmod +t dir`：授予一个目录`dir`sticky权限，得到`drwxrwxrwt`。

（5）通过`umask`设置默认权限：直接使用`umask`命令得到的是默认的权限（macOS为`022`），代表的含义是文件所有者同组用户和其他用户没有写权限（展开即`000 010 010`，出现`1`的位置表示关闭对应的文件属性）。默认情况下，`umask`命令设置的掩码值只能在当前shell会话中生效，若当前shell会话结束后，则必须重新设置。

（6）`su`和`sudo`：`su`命令允许我们假定为另一个用户的身份（substitute user identity），以这个用户的ID**启动一个新的shell会话**，或者是以这个用户的身份来**发布一个命令**。相比之下，`sudo`命令允许一个管理员设置一个叫做`/etc/sudoers`的配置文件，并且定义了一些具体命令，在假定的身份下，特殊用户可以**执行这些命令**。不同的类Unix系统可能会偏袒其中之一。在macOS中。通过`sudo -i`命令并输入当前用户的密码即可登陆root用户的shell。（具体地，给一个普通用户分配超级用户权限，需要一个拥有超级用户权限的用户在`/etc/sudoers`中的适当位置添加`user-name ALL=(ALL) ALL`，其中`user-name`是该普通用户的名字。）

（7）一般情况下，不要以root账户操作系统，因为这会导致Linux系统的安全性能被降低到和Windows系统相同的级别:-)。

（8）通过`chown [owner][:[group]] file ...`改变（一个或多个）文件的所有者和用户组。下面的示例意为janet（具有root权限）将她自己家目录的文件复制到tony的家目录并给予tony读写权限。
```shell
[janet@busybox ~]$ sudo cp myfile.txt ~tony
Password:
[janet@busybox ~]$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 root  root 8031 2008-03-20 14:30 /home/tony/myfile.txt
[janet@busybox ~]$ sudo chown tony: ~tony/myfile.txt
[janet@busybox ~]$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 tony  tony 8031 2008-03-20 14:30 /home/tony/myfile.txt
```
`chgrp`用来更改用户组所有权，这其实可以由`chown`来实现。之所以会有这个命令是因为旧版Unix系统中`chown`命令只能更改文件所有权。

（9）**彻底理解下面这个例子：**<br>
假想我们有两个用户，他们分别是bill和karen。他们都有音乐CD收藏品，也愿意设置一个共享目录，在这个共享目录中，他们分别以Ogg Vorbis或MP3的格式来存储他们的音乐文件。通过sudo命令，用户bill具有超级用户访问权限。

【9.1】创建一个以bill和karen为成员的用户组`music`。

【9.2】bill在他的家目录之外通过root权限创建一个共享目录：
```shell
[bill@busybox ~]$ sudo mkdir /usr/local/share/Music
password:
[bill@busybox ~]$ ls -ld /usr/local/share/Music
drwxr-xr-x 2 root root 4096 2008-03-21 18:05 /usr/local/share/Music
```
注意，这个目录由root用户所有，并且权限为755。为了使这个目录共享，允许（用户karen）写入，bill需要更改目录用户组所有权和权限：
```shell
[bill@busybox ~]$ sudo chown :music /usr/local/share/Music
[bill@busybox ~]$ sudo chmod 775 /usr/local/share/Music
[bill@busybox ~]$ ls -ld /usr/local/share/Music
drwxrwxr-x 2 root music 4096 2008-03-21 18:05 /usr/local/share/Music
```
现在这个目录由root用户拥有，并且允许用户组`group`读取和写入。因此，bill和karen能够在目录`/usr/local/share/Music`中创建文件。其他用户能够列出目录中的内容，但是不能在其中创建文件。但是，这就没问题了吗？

**问题1**：现在bill在该目录下创建了一个文件，观察可发现该文件仅具有bill和karen的普通权限：
```shell
[bill@busybox ~]$ > /usr/local/share/Music/test_file
[bill@busybox ~]$ ls -l /usr/local/share/Music
-rw-r--r-- 1 bill    bill    0 2008-03-24 20:03 test_file
```
因为系统默认的掩码值为`0022`（linux系统），因此karen此时无法修改bill创建的文件。如果这是一个音频文件，那么不修改它也没什么问题，但是通常音频会按照艺术家、日期和专辑的方式存储，是需要在该共享目录下创建新目录的，如果不具备对该共享目录下的目录的写权限，那么karen就无法添加音频！解决方案：修改掩码值。

**问题2**：bill创建的文件和目录的用户组默认是bill的主要组，而非用户组`music`。解决方案：设置此共享目录的setgid位。
```shell
[bill@busybox ~]$ sudo chmod g+s /usr/local/share/Music
[bill@busybox ~]$ ls -ld /usr/local/share/Music
drwxrwsr-x 2 root music 4096 2008-03-24 20:03 /usr/local/share/Music

[bill@busy box ~]$ umask 0002

[bill@busybox ~]$ rm /usr/local/share/Music/test_file

[bill@busybox ~]$ > /usr/local/share/Music/test_file
[bill@busybox ~]$ mkdir /usr/local/share/Music/test_dir
[bill@busybox ~]$ ls -l /usr/local/share/Music
drwxrwsr-x 2 bill   music 4096 2008-03-24 20:24 test_dir
-rw-rw-r-- 1 bill   music 0 2008-03-24 20:22 test_file
```
现在，创建的文件和目录都具有正确的权限，允许用户组music的所有成员在目录Music中创建文件和目录。

（10）通过`passwd [user]`修改自己或指定用户`user`的密码。

### 进程
16、进程

（1）进程，就是Linux组织安排正在等待使用CPU的各种程序的方式。需要熟练掌握的命令：
- `ps` – 报告当前进程快照（process status）
- `top` – 显示任务
- `jobs` – 列出活跃的任务
- `bg` – 把一个任务放到后台执行
- `fg` – 把一个任务放到前台执行
- `kill` – 给一个进程发送信号
- `killall` – 杀死指定名字的进程
- `shutdown` – 关机或重启系统

（2）当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做`init`的程序。`init`，依次地，再运行一系列的称为`init`脚本的shell脚本（位于`/etc`），它们可以启动所有的系统服务。其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口（User Interface）。这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。

（3）在进程方案中，一个程序可以发起（launch）另一个程序被表述为**一个父进程可以产生一个子进程**。
内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做进程ID或PID。PID号按升序分配，init进程的PID总是1。内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。像文件一样，进程也有所有者、用户ID和有效用户ID等。

（4）使用`ps`命令：默认情况下，`ps`不会显示很多进程信息，只是列出与当前终端会话相关的进程。其中`TTY`指进程的控制终端（下面的例子中，终端编号为`s000`）。
```shell
(base) ➜  ~ ps
  PID TTY           TIME CMD
82302 ttys000    0:01.87 -zsh
```
（5）使用`ps x`显示所有进程：
```shell
(base) ➜  ~ ps x
  PID   TT  STAT      TIME COMMAND
  348   ??  S      0:00.60 /System/Library/Frameworks/LocalAuthentication.framework/Support/coreauthd
  350   ??  S      1:05.19 /usr/sbin/cfprefsd agent
  ... ...
82301 s000  Ss     0:00.08 login -fp hliangzhao        # 小写的s表示session leader
82302 s000  S      0:01.93 -zsh
85867 s000  R+     0:00.00 ps x
```
其中`??`表示没有控制终端，`STAT`表示当前状态（通过`man ps`查询更为细致的状态）：

| 状态 | 含义
| --- | ---
| `R` | 运行中。这意味着，进程正在运行或准备运行。
| `S` | 正在睡眠。进程没有运行，而是，正在等待一个事件，比如说，一个按键或者网络分组。
| `D` | 不可中断睡眠。进程正在等待I/O，比方说，一个磁盘驱动器的I/O。
| `T` | 已停止。已经指示进程停止运行。
| `Z` | 一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。（父进程没有把子进程从进程表中删除）
| `<` | 一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的CPU时间。进程的这种属性叫做niceness。具有高优先级的进程据说是不好的（less nice），因为它占用了比较多的CPU时间，这样就给其它进程留下很少时间。
| `N` | 低优先级进程。一个低优先级进程（一个“nice”进程）只有当其它高优先级进程被服务了之后，才会得到处理器时间。

通过`man ps`查阅`ps`命令输出的各个字段的详细含义。

（6）使用`ps aux`显示属于每个用户的进程信息。下面给出了macOS下的输出。其中`RSS`表示进程占用的物理内存的大小，以千字节为单位。`VSZ`表示虚拟内存大小。
```shell
(base) ➜  ~ ps aux
USER               PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND
hliangzhao       91320   1.3  0.0  4335120   5220 s000  S    10:15PM   0:00.60 -zsh
hliangzhao         364   1.2  0.0  4351608   4884   ??  S    Tue02PM   1:44.93 /usr/sbin/distnoted agent
```

（7）`ps`提供的是命令执行时刻的快照，用`top`查看动态实时的信息。

（8）使用Ctrl-c，中断一个程序。这意味着，我们礼貌地要求终止这个程序。使用`proc &`将进程`proc`放在后台执行。通过`fg %job-id`将job编号为`job-id`的进程放在前台运行。显然，通过`bg %job-id`又可以将job编号为`job-id`的进程放到后台。区分suspended和terminated！
```shell
(base) ➜  ~ ps
  PID TTY           TIME CMD
91320 ttys000    0:01.42 -zsh
(base) ➜  ~ python &
[1] 92274
Python 3.7.9 (default, Aug 31 2020, 07:22:35)
[Clang 10.0.0 ] :: Anaconda, Inc. on darwin
Type "help", "copyright", "credits" or "license" for more information.
[1]  + 92274 suspended (tty output)  python       # job的id为1
(base) ➜  ~ ps
  PID TTY           TIME CMD
91320 ttys000    0:01.53 -zsh
92274 ttys000    0:00.03 python
(base) ➜  ~ jobs
[1]  + suspended (tty output)  python
(base) ➜  ~ fg %1                      # 不加上job id也可以，因为只有一个job
[1]  + 92274 continued  python
>>> print("hello")
hello
>>>
[1]  + 92274 suspended  python         # 此处使用Ctrl-z停止一个前台进程（即放到后台运行）
```

（9）通过`kill PID`或者`kill %job-id`杀死一个PID为`PID`（或job id为`job-id`）的进程（terminated）。
`kill`命令不是真的“杀死”程序，而是给程序发送信号。
**信号是操作系统与程序之间进行通信时所采用的几种方式中的一种。**
在使用Ctrl-c和Ctrl-z的过程中我们已经看到信号的实际用法。当终端接受了其中一个按键组合后，它会给在前端运行的程序发送一个信号。
**在使用Ctrl-c的情况下，会发送一个叫做INT（Interrupt，中断）的信号；当使用Ctrl-z时，则发送一个叫做TSTP（Terminal Stop，终端停止。不是kill！）的信号。**
相应地，程序监听信号的到来并做出响应。一个程序能够监听和响应信号这件事允许一个程序做些事情，比如，当程序接到一个终止信号时，它可以保存所做的工作。

（10）如上所述，`kill`的语法形式其实是这样：`kill [-signal] PID`，当没有指定signal时，默认为发送terminate信号。signal指定方式：`kill -编号 PID`或者`kill -SIG名字 PID`（例如，`kill -1 27747`，`kill -SIGINT 27747`等）。此外，信号的发送者必须为进程的所有者或者超级用户。

| 编号 | 名字 | 含义
| --- | --- | ---
| 1 | HUP | 挂起（Hangup）。这是美好往昔的残留部分，那时候终端机通过电话线和调制解调器连接到远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂断”。通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后，这个进程会重新启动，并且重新读取它的配置文件。Apache网络服务器守护进程就是一个例子。
| 2 | INT | **中断。实现和Ctrl-c一样的功能，由终端发送。通常，它会终止一个程序。**
| 9 | KILL | 杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的信号，其中也包含忽略信号，但是KILL信号从不被发送到目标程序。而是内核立即终止这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。因为这个原因，把KILL信号看作最后一招，当其它终止信号失败后，再使用它。
| 15 | TERM | 终止。这是kill命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么这个它会终止。
| 18 | CONT | 继续。在一个停止信号后，这个信号会恢复进程的运行。
| 19 | STOP | 停止。这个信号导致进程停止运行，而不是终止。像KILL信号，它不被发送到目标进程，因此它不能被忽略。
| 3 | QUIT | 退出
| 11 | SEGV | 段错误（Segmentation Violation）。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。
| 20 | TSTP | **终端停止(Terminal Stop)。当按下Ctrl-z组合键后，终端发送这个信号。不像STOP信号，TSTP信号由目标进程接收，且可能被忽略。**
| 28 | WINCH | 改变窗口大小（Window Change）。当改变窗口大小时，系统会发送这个信号。 一些程序，像top和less程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。